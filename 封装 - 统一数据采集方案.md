# å°è£… - ç»Ÿä¸€æ•°æ®é‡‡é›†æ–¹æ¡ˆ
### æ¦‚è¿°

é€šå¸¸ä¸€ä¸ªå…¨æ–°åŠŸèƒ½ä¸Šçº¿éƒ½ä¼šé‡‡é›†ç”¨æˆ·è¡Œä¸ºæ•°æ®ï¼Œåˆ†ææ–°åŠŸèƒ½ä½¿ç”¨æƒ…å†µï¼Œä¾¿äºåç»­å®Œå–„ä¼˜åŒ–ã€‚è€Œé‡‡é›†æ•°æ®çš„è¡Œä¸ºä¸€èˆ¬æœ‰ä¸‰ä¸ªç»´åº¦ï¼šå…ƒç´ ç‚¹å‡»ã€å…ƒç´ æ‚¬åœã€å…ƒç´ æ›å…‰ï¼Œä¸‹æ–‡å°†ç ”è®¨å¦‚ä½•ä¼˜é›…åœ°é‡‡é›†è¿™ä¸‰ä¸ªç»´åº¦çš„æ•°æ®ã€‚

### æ–¹æ¡ˆ

#### åŸç”Ÿé‡‡é›†

åŸç”Ÿé‡‡é›†é¡¾åæ€ä¹‰å°±æ˜¯ä¸åšä»»ä½•å°è£…ï¼Œç›´æ¥è°ƒç”¨ç¬¬ä¸‰æ–¹æ•°æ®é‡‡é›†å¹³å°æä¾›çš„`SDK`ï¼ˆæ¯”å¦‚ï¼Œç¥ç­–æä¾›çš„`Web JS SDK`ï¼‰ã€‚

```
const memoRef = useRef({});
const wait = 2000;

const handleClickTrack = () =\> {
    if (memoRef.current.prevClickTime) {
        
        return;
    }
    if (wait) {
        
        if (Date.now() \- memoRef.current.prevClickTime >= wait) {
            cassSensors.track(eventName, eventData);
            memoRef.current.prevClickTime = Date.now();
        }
    } else {
        
        cassSensors.track(eventName, eventData);
        memoRef.current.prevClickTime = Date.now();
    }
}

<Button onClick={handleClickTrack} />
```

è¿™ç§é‡‡é›†æ–¹å¼ç®€å•ç²—æš´å¯é ï¼Œç†è§£ç®€å•ï¼Œä½†ç¼ºç‚¹ä¹Ÿçªå‡ºï¼Œç›®æ ‡é‡‡é›†å…ƒç´ çš„ç»„ä»¶å†…éƒ¨éƒ½éœ€è¦å®ç°é‡‡é›†é€»è¾‘ï¼Œå¯¹ä¸šåŠ¡ä»£ç çš„ä¾µå…¥æ€§è¾ƒå¼ºï¼Œä¸ä¾¿äºé•¿æœŸè¿­ä»£ç»´æŠ¤ã€‚æ¯”å¦‚ï¼Œæœ‰ä¸€å¤©å…¬å¸å†³å®šç”¨`GrowingIO`æ›¿æ¢æˆç¥ç­–`Web JS SDK`ï¼Œæ˜¯ä¸æ˜¯æ¶‰åŠåˆ°çš„æ¯ä¸ªå·¥ç¨‹æ–‡ä»¶éƒ½è¦æ›´æ”¹ä»£ç å‘¢ï¼Ÿï¼‰ã€‚

#### Hooks

`Hooks`åˆ©ç”¨äº‹ä»¶å†’æ³¡æœºåˆ¶ç²¾å‡†æ‹¦æˆªç›®æ ‡å…ƒç´ é‡‡é›†è¡Œä¸ºï¼Œå±äºä¸€ç§åˆ‡é¢æ€æƒ³ï¼ŒæŠ½ç¦»é‡‡é›†é€»è¾‘ï¼Œé™ä½å¯¹ä¸šåŠ¡ç»„ä»¶çš„ä¾µå…¥æ€§ã€‚

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      #root {
        width: 100%;
        height: 100%;
        overflow-y: scroll;
      }

      .container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .card {
        width: 400px;
        height: 200px;
        border: 1px solid #8c8c8c;
        margin-bottom: 10px;
      }

      .wrap {
        position: relative;
        display: inline-block;
        overflow: hidden;
      }

      .target {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translateX(-50%) translateY(-50%);
        width: 100px;
        height: 50px;
        border: 1px solid #8c8c8c;
        background-color: #ccc;
      }
    </style>
  </head>

  <body>
    <div id="root"></div>
    <script>
      /** ä¸ŠæŠ¥å‡½æ•° */
      window.cassSensors = {
        track: (eventName, eventData) => {
          console.log(eventName, eventData);
        },
      };

      /** hooks */
      const useTrackable = (comp, options) => {
        const { eventName, eventType, eventData, once, wait } = options;
        /** ç¼“å­˜åŸ‹ç‚¹<string, object> */
        const momeRef = React.useRef(new Map());
        /** å½“å‰å…ƒç´ çš„å”¯ä¸€id */
        const uuidRef = React.useRef(Math.random().toString(36).slice(2));
        /** æ¸²æŸ“Ref */
        const renderRef = React.createRef(null);
        /** åˆå§‹åŒ–ç¼“å­˜ */
        React.useMemo(() => {
          momeRef.current.set(uuidRef.current, {});
        }, []);

        /** ç‚¹å‡»åŸ‹ç‚¹ */
        const handleClickTrack = React.useCallback(() => {
          const uuid = uuidRef.current;
          if (once && momeRef.current.get(uuid).prevClickTime) {
            /** å·²ç»é‡‡é›†è¿‡ï¼Œä¸ç”¨å†æ¬¡é‡‡é›† */
            return;
          }

          if (wait) {
            if (
              Date.now() - (momeRef.current.get(uuid).prevClickTime || 0) >=
              wait
            ) {
              cassSensors.track(eventName, eventData);
              momeRef.current.get(uuid).prevClickTime = Date.now();
            }
          } else {
            cassSensors.track(eventName, eventData);
            momeRef.current.get(uuid).prevClickTime = Date.now();
          }
        }, []);

        /** æ‚¬åœåŸ‹ç‚¹ */
        const handleMouseoverTrack = React.useCallback((e) => {
          const uuid = uuidRef.current;
          if (once && momeRef.current.get(uuid).prevHoverTime) {
            /** å·²ç»é‡‡é›†è¿‡ï¼Œä¸ç”¨å†æ¬¡é‡‡é›† */
            return;
          }

          if (momeRef.current.get(uuid).hoverTimer) {
            return;
          }

          if (wait) {
            momeRef.current.get(uuid).hoverTimer = setTimeout(() => {
              cassSensors.track(eventName, eventData);
              momeRef.current.get(uuid).prevHoverTime = Date.now();
              clearTimeout(momeRef.current.get(uuid).hoverTimer);
              momeRef.current.get(uuid).hoverTimer = null; // clearTimeoutå¯ä»¥æ¸…é™¤å®šæ—¶å™¨ï¼Œä½†ä¸ä¼šå°†hoverTimerå€¼ç½®ğŸˆ³ï¸
            }, wait);
          } else {
            cassSensors.track(eventName, eventData);
            momeRef.current.get(uuid).prevHoverTime = Date.now();
            clearTimeout(momeRef.current.get(uuid).hoverTimer);
            momeRef.current.get(uuid).hoverTimer = null;
          }
        });

        const handleMouseleaveTrack = React.useCallback((e) => {
          /** æ¸…é™¤å®šæ—¶å™¨ */
          const uuid = uuidRef.current;
          clearTimeout(momeRef.current.get(uuid).hoverTimer);
          momeRef.current.get(uuid).hoverTimer = null;
        });

        // æ˜¯å¦åœ¨å¯è§†åŒºåŸŸå†…ï¼ˆå±å¹•ä¸­å¤® ä¸Šä¸‹80%èŒƒå›´ï¼‰
        const isInViewPort = React.useCallback((ele) => {
          var viewWidth = document.documentElement.clientWidth;
          var viewHeight = document.documentElement.clientHeight;
          var elePos = ele.getBoundingClientRect();
          return (
            elePos.top >= viewHeight * 0.1 &&
            elePos.left >= 0 &&
            elePos.right <= viewWidth &&
            elePos.bottom <= viewHeight * 0.9
          );
        });

        /** æ›å…‰åŸ‹ç‚¹ */
        const handleScrollTrack = React.useCallback(() => {
          const uuid = uuidRef.current;
          const targetEle = document.getElementById(uuid);

          if (once && momeRef.current.get(uuid).prevScrollTime) {
            return;
          }

          if (isInViewPort(targetEle)) {
            if (wait) {
              if (momeRef.current.get(uuid).scrollTimer) {
                return;
              }
              momeRef.current.get(uuid).scrollTimer = setTimeout(() => {
                cassSensors.track(eventName, eventData);
                momeRef.current.get(uuid).prevScrollTime = Date.now();
                clearTimeout(momeRef.current.get(uuid).scrollTimer);
                momeRef.current.get(uuid).scrollTimer = null;
              }, wait);
            } else {
              cassSensors.track(eventName, eventData);
              momeRef.current.get(uuid).prevScrollTime = Date.now();
              clearTimeout(momeRef.current.get(uuid).scrollTimer);
              momeRef.current.get(uuid).scrollTimer = null;
            }
          } else {
            clearTimeout(momeRef.current.get(uuid).scrollTimer);
            momeRef.current.get(uuid).scrollTimer = null;
          }
        });

        /** é˜²æŠ– */
        const debounce = React.useCallback((fn, wait) => {
          let timer = null;
          return function (args) {
            const that = this;
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }

            timer = setTimeout(() => {
              fn.call(that, args);
              clearTimeout(timer);
              timer = null;
            }, wait);
          };
        });

        React.useEffect(() => {
          const $wrap = document.getElementById(uuidRef.current);
          if (eventType === "click" && $wrap) {
            /** å†’æ³¡æ•è· */
            $wrap.addEventListener(eventType, handleClickTrack, false);
          }
          /** mouseenterå’Œmouseleaveäº‹ä»¶ä¸æ”¯æŒæ•è·å†’æ³¡ */
          if (eventType === "mouseover" && $wrap) {
            $wrap.addEventListener("mouseenter", handleMouseoverTrack, false);
            // è¿™å„¿ä¸èƒ½ä½¿ç”¨mouseoutï¼Œå½“åŒ…è£¹å…ƒç´ é‡Œå«æœ‰å­å…ƒç´ ï¼Œå¦‚æœé¼ æ ‡ä»åŒ…è£¹å…ƒç´ ç§»åˆ°å­å…ƒç´ ä¹Ÿä¼šè§¦å‘mouseoutï¼Œä½†é¼ æ ‡å¹¶æ²¡æœ‰ç¦»å¼€åŒ…è£¹å…ƒç´ èŒƒå›´
            // åªæœ‰é¼ æ ‡ç¦»å¼€åŒ…è£¹å…ƒç´ èŒƒå›´æ‰ä¼šè§¦å‘mouseleave
            $wrap.addEventListener("mouseleave", handleMouseleaveTrack, false);
          }

          /** scrollä¹Ÿä¸æ”¯æŒäº‹ä»¶æ•è·å†’æ³¡ */
          const debounceScrollTrack = debounce(handleScrollTrack, 200);
          if (eventType === "scroll") {
            const $container = document.getElementById("root");
            if ($container) {
              $container.addEventListener("scroll", debounceScrollTrack, false);
            }
          }

          return () => {
            /** æ³¨é”€äº‹ä»¶ */
            if (eventType === "click" && $wrap) {
              $wrap.removeEventListener(eventType, handleClickTrack, false);
            }
            if (eventType === "mouseover" && $wrap) {
              $wrap.removeEventListener('mouseenter', handleMouseoverTrack, false);
              $wrap.removeEventListener('mouseleave', handleMouseleaveTrack, false);
            }
            if (eventType === "scroll") {
              const $container = document.getElementById("root");
              if ($container) {
                $container.removeEventListener("scroll", debounceScrollTrack, false);
              }
            }
          };
        }, []);

        React.useEffect(() => {
          if (eventType === "scroll" && renderRef && renderRef.current) {
            const uuid = uuidRef.current;
            // è¯´æ˜ç›®æ ‡å…ƒç´ å·²ç»æ¸²æŸ“åˆ°é¡µé¢ä¸Šï¼Œå¯ä»¥é‡‡é›†åˆ°é¡µé¢æ²¡æœ‰æ»šåŠ¨æ—¶çš„ç¬¬ä¸€å¸§ç”»é¢æ›å…‰çš„å…ƒç´ 
            if (
              isInViewPort(renderRef.current) &&
              !momeRef.current.get(uuid).scrollTimer &&
              !momeRef.current.get(uuid).prevScrollTime
            ) {
              if (wait) {
                momeRef.current.get(uuid).scrollTimer = setTimeout(() => {
                  cassSensors.track(eventName, eventData);
                  momeRef.current.get(uuid).prevScrollTime = Date.now();
                  clearTimeout(momeRef.current.get(uuid).scrollTimer);
                  momeRef.current.get(uuid).scrollTimer = null;
                }, wait);
              } else {
                cassSensors.track(eventName, eventData);
                momeRef.current.get(uuid).prevScrollTime = Date.now();
                clearTimeout(momeRef.current.get(uuid).scrollTimer);
                momeRef.current.get(uuid).scrollTimer = null;
              }
            }
          }
        }, [renderRef]);

        return React.createElement(
          "div",
          { id: uuidRef.current, ref: renderRef, className: "wrap" },
          React.createElement(comp, {}, null)
        );
      };

      /** ç›®æ ‡å…ƒç´  */
      const Button = () => {
        return React.createElement(
          "div",
          { className: "card" },
          React.createElement("span", {}, React.createElement('div', { className: 'target' }, 'ç›®æ ‡å…ƒç´ '))
        );
      };

      /**  */
      const TrackButtonWrap = () => {
        /** ScrollTrackButtonå¾—åˆ°çš„æ˜¯ä¸€ä¸ªobjectï¼Œä¸èƒ½ä½œä¸ºcreateElementçš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå¿…é¡»ä¸ºstring | functionComponent | classComponent */
        const ScrollTrackButton = useTrackable(Button, {
          once: true,
          wait: 2000,
          eventName: "SCROLL_EVENT",
          eventType: "scroll",
          eventData: JSON.stringify({ id: "scroll" }),
        });
        const ClickTrackButton = useTrackable(() => ScrollTrackButton, {
          once: false,
          wait: 2000,
          eventName: "CLICK_EVENT",
          eventType: "click",
          eventData: JSON.stringify({ id: "click" }),
        });
        const HoverTrackButton = useTrackable(() => ClickTrackButton, {
          once: true,
          wait: 2000,
          eventName: "HOVER_EVENT",
          eventType: "mouseover",
          eventData: JSON.stringify({ id: "mouseover" }),
        });
        return React.createElement("div", {}, HoverTrackButton);
      };
      
      ReactDOM.createRoot(document.getElementById("root")).render(
        React.createElement("div", { className: "container" }, [
          React.createElement("div", { className: "card" }, null),
          React.createElement(TrackButtonWrap, {}, null),
          React.createElement("div", { className: "card" }, null),
          React.createElement("div", { className: "card" }, null),
          React.createElement("div", { className: "card" }, null),
          React.createElement("div", { className: "card" }, null),
        ])
      );
    </script>
  </body>
</html>
```

ä¸Šè¿°ä»£ç ä¸­æœ‰ä»¥ä¸‹å‡ å¤„éœ€è¦æ³¨æ„ï¼š

#### HOC

é«˜é˜¶ç»„ä»¶ä¸`Hooks`å®ç°æ€æƒ³ç±»ä¼¼ï¼Œä½†æ˜¯é«˜é˜¶ç»„ä»¶éœ€è¦å°†ç›®æ ‡å…ƒç´ å•ç‹¬æŠ½ç¦»æˆç»„ä»¶åŒ…è£…ï¼Œç›¸å¯¹è€Œè¨€ï¼Œæ²¡æœ‰`Hooks`ç®€ä¾¿

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    <style> html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      #root {
        width: 100%;
        height: 100%;
        overflow-y: scroll;
      }

      .container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .card {
        width: 400px;
        height: 200px;
        border: 1px solid #8c8c8c;
        margin-bottom: 10px;
      }

      .wrap {
        position: relative;
        display: inline-block;
        overflow: hidden;
      }

      .target {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translateX(-50%) translateY(-50%);
        width: 100px;
        height: 50px;
        border: 1px solid #8c8c8c;
        background-color: #ccc;
      } </style>
  </head>

  <body>
    <div id="root"></div>
    <script> window.cassSensors = {
        track: (eventName, eventData) => {
          console.log(eventName, eventData);
        },
      };

      const trackHOC = (comp, options) =\> {
        const { eventName, eventType, eventData, once, wait } = options;
        const uuid = Math.random().toString(36).slice(2);
        const memo = new Map().set(uuid, {}); 
        return class TrackWrap extends React.Component {
          constructor(props) {
            super(props);
          }

          
          handleClickTrack = () => {
            if (once && memo.get(uuid).prevClickTime) {
              
              return;
            }

            if (wait) {
              if (Date.now() \- (memo.get(uuid).prevClickTime || 0) >= wait) {
                cassSensors.track(eventName, eventData);
                memo.get(uuid).prevClickTime = Date.now();
              }
            } else {
              cassSensors.track(eventName, eventData);
              memo.get(uuid).prevClickTime = Date.now();
            }
          };

          
          handleMouseenterTrack = () => {
            if (once && memo.get(uuid).prevHoverTime) {
              
              return;
            }

            if (memo.get(uuid).hoverTimer) {
              return;
            }

            if (wait) {
              memo.get(uuid).hoverTimer = setTimeout(() => {
                cassSensors.track(eventName, eventData);
                memo.get(uuid).prevHoverTime = Date.now();
                clearTimeout(memo.get(uuid).hoverTimer);
                memo.get(uuid).hoverTimer = null; 
              }, wait);
            } else {
              cassSensors.track(eventName, eventData);
              memo.get(uuid).prevHoverTime = Date.now();
              clearTimeout(memo.get(uuid).hoverTimer);
              memo.get(uuid).hoverTimer = null;
            }
          };

          handleMouseleaveTrack = (e) => {
            
            clearTimeout(memo.get(uuid).hoverTimer);
            memo.get(uuid).hoverTimer = null;
          };

          
          isInViewPort = (ele) => {
            var viewWidth = document.documentElement.clientWidth;
            var viewHeight = document.documentElement.clientHeight;
            var elePos = ele.getBoundingClientRect();
            return (
              elePos.top >= viewHeight * 0.1 &&
              elePos.left >= 0 &&
              elePos.right <= viewWidth &&
              elePos.bottom <= viewHeight * 0.9
            );
          };

          
          debounce = (fn, wait) => {
            let timer = null;
            return function (args) {
              const that = this;
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }

              timer = setTimeout(() => {
                fn.call(that, args);
                clearTimeout(timer);
                timer = null;
              }, wait);
            };
          };

          handleScrollTrack = () => {
            const targetEle = document.getElementById(uuid);

            if (once && memo.get(uuid).prevScrollTime) {
              return;
            }

            if (this.isInViewPort(targetEle)) {
              if (wait) {
                if (memo.get(uuid).scrollTimer) {
                  return;
                }
                memo.get(uuid).scrollTimer = setTimeout(() => {
                  cassSensors.track(eventName, eventData);
                  memo.get(uuid).prevScrollTime = Date.now();
                  clearTimeout(memo.get(uuid).scrollTimer);
                  memo.get(uuid).scrollTimer = null;
                }, wait);
              } else {
                cassSensors.track(eventName, eventData);
                memo.get(uuid).prevScrollTime = Date.now();
                clearTimeout(memo.get(uuid).scrollTimer);
                memo.get(uuid).scrollTimer = null;
              }
            } else {
              clearTimeout(memo.get(uuid).scrollTimer);
              memo.get(uuid).scrollTimer = null;
            }
          };

          componentDidMount() {
            const $wrap = document.getElementById(uuid);
            if (eventType === "click" && $wrap) {
              
              $wrap.addEventListener(eventType, this.handleClickTrack, false);
            }

            
            if (eventType === "mouseover" && $wrap) {
              $wrap.addEventListener(
                "mouseenter",
                this.handleMouseenterTrack,
                false
              );
              $wrap.addEventListener(
                "mouseleave",
                this.handleMouseleaveTrack,
                false
              );
            }

            
            if (eventType === "scroll") {
              const $container = document.getElementById("root");
              const targetEle = document.getElementById(uuid);
              if ($container) {
                $container.addEventListener(
                  "scroll",
                  this.debounce(this.handleScrollTrack, 100),
                  false
                );
              }
              
              if (
                targetEle &&
                this.isInViewPort(targetEle) &&
                !memo.get(uuid).scrollTimer &&
                !memo.get(uuid).prevScrollTime
              ) {
                if (wait) {
                  memo.get(uuid).scrollTimer = setTimeout(() => {
                    cassSensors.track(eventName, eventData);
                    memo.get(uuid).prevScrollTime = Date.now();
                    clearTimeout(memo.get(uuid).scrollTimer);
                    memo.get(uuid).scrollTimer = null;
                  }, wait);
                } else {
                  cassSensors.track(eventName, eventData);
                  memo.get(uuid).prevScrollTime = Date.now();
                  clearTimeout(memo.get(uuid).scrollTimer);
                  memo.get(uuid).scrollTimer = null;
                }
              }
            }
          }

          render() {
            return React.createElement(
              "div",
              { id: uuid, className: "wrap" },
              React.createElement(comp, {}, null)
            );
          }
        };
      };

      
      const Button = () =\> {
        return React.createElement(
          "div",
          { className: "card" },
          React.createElement("div", { className: "target" }, "ç›®æ ‡å…ƒç´ ")
        );
      };

      
      const TrackButtonWrap = () =\> {
        
        const ScrollTrackButton = trackHOC(Button, {
          once: false,
          wait: 2000,
          eventName: "SCROLL_EVENT",
          eventType: "scroll",
          eventData: JSON.stringify({ id: "scroll" }),
        });
        const ClickTrackButton = trackHOC(ScrollTrackButton, {
          once: true,
          eventName: "CLICK_EVENT",
          eventType: "click",
          eventData: JSON.stringify({ id: "click" }),
        });
        const HoverTrackButton = trackHOC(ClickTrackButton, {
          once: false,
          wait: 2000,
          eventName: "HOVER_EVENT",
          eventType: "mouseover",
          eventData: JSON.stringify({ id: "mouseover" }),
        });
        return React.createElement(HoverTrackButton, {}, null);
      };

      ReactDOM.createRoot(document.getElementById("root")).render(
        React.createElement("div", { className: "container" }, \[
          React.createElement("div", { className: "card" }, null),
          React.createElement(TrackButtonWrap, {}, null),
          React.createElement("div", { className: "card" }, null),
          React.createElement("div", { className: "card" }, null),
          React.createElement("div", { className: "card" }, null),
          React.createElement("div", { className: "card" }, null),
        \])
      ); </script>
  </body>
</html>
```

#### æ’æ‹”å¼

å‰ç«¯å·¥ç¨‹çš„æŠ€æœ¯æ ˆæœ‰å¾ˆå¤šï¼Œ`Spring MVCã€Vueã€React`ç­‰ï¼Œå¦‚æœæ¯ç§æŠ€æœ¯æ ˆéƒ½å»å®ç°ä¸€éï¼ŒåŒæ­¥ç»´æŠ¤ï¼Œæˆæœ¬å°±æ¯”è¾ƒé«˜äº†ã€‚æ•°æ®é‡‡é›†éƒ½æ˜¯é€šè¿‡äº‹ä»¶æœºåˆ¶è§¦å‘ï¼Œè°ƒç”¨ç¬¬ä¸‰æ–¹`SDK`ä¸ŠæŠ¥ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åˆ©ç”¨äº‹ä»¶æ•è·å†’æ³¡æœºåˆ¶æ‹¦æˆªäº‹ä»¶æµï¼Œç»Ÿä¸€å°è£…é‡‡é›†é€»è¾‘ï¼Œé…ç½®é¡¹é›†æˆåœ¨ç›®æ ‡å…ƒç´ ä¸Šã€‚  
![](https://segmentfault.com/img/bVc4z3R)

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!--  IE 11ä»¥ä¸‹ä¸å…¼å®¹MutationObserver APIï¼Œå¼•å…¥polyfill -->
    <script src="./MutationObserver.js"></script>
    <title>Document</title>
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      #root {
        width: 100%;
        height: 100%;
        overflow-y: scroll;
      }

      .container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .card {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        width: 400px;
        height: 200px;
        border: 1px solid #8c8c8c;
        margin-bottom: 10px;
      }

      .target {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translateX(-50%) translateY(-50%);
        width: 100px;
        height: 50px;
        border: 1px solid #8c8c8c;
        background-color: #ccc;
      }
    </style>
  </head>

  <body>
    <div id="root">
      <div class="container">
        <div class="card"></div>
        <div class="card">
          <div
            data-exposure
            data-eventname="SCROLL_EVENT"
            data-eventtype="scroll"
            data-eventdata="{ id: 'scroll' }"
            data-once="false"
            data-wait="2000"
            data-uuid="ucwbsrt6l48"
          >
            <div
              onclick="handleClickTrack()"
            >
              <div
                data-eventname="MOUSEOVER_EVENT"
                data-eventtype="mouseover"
                data-eventdata="{ id: 'mouseover' }"
                data-once="false"
                data-wait="2000"
                data-uuid="v3s7a7030yp"
              >
                ç›®æ ‡å…ƒç´ 
              </div>
            </div>
          </div>
        </div>
        <div class="card"></div>
        <div class="card"></div>
      </div>
    </div>
    <script>
      // æ‰‹åŠ¨é‡‡é›†ç‚¹å‡»äº‹ä»¶
      var handleClickTrack = function() {
        cassSensors.track('CLICK_EVENT', { id: 'click' });
      }
    </script>
    <script>
      /** ä¸ŠæŠ¥å‡½æ•° */
      window.cassSensors = {
        track: function (eventName, eventData) {
          console.log(eventName, eventData);
        },
      };

      /**
       * é‡‡é›†å…ƒç´ å±æ€§
       * data-eventname: äº‹ä»¶åç§°
       * data-eventdata: é‡‡é›†æ•°æ®ï¼ŒJSONå­—ç¬¦ä¸²ç±»å‹
       * data-eventtype: é‡‡é›†äº‹ä»¶ç±»å‹ï¼Œ'click' | 'mouseover' | 'scroll'ï¼Œ'click'è¡¨ç¤ºç‚¹å‡»äº‹ä»¶ï¼Œ'mouseover'è¡¨ç¤ºæ‚¬æµ®äº‹ä»¶ï¼Œ'scroll'è¡¨ç¤ºæ›å…‰äº‹ä»¶
       * data-once: äº‹ä»¶è§¦å‘æ¬¡æ•°ï¼Œ'true' | 'false'ï¼Œtrueè¡¨ç¤ºåªä¼šé‡‡é›†ä¸€æ¬¡ï¼Œfalseè¡¨ç¤ºæ¯æ¬¡è§¦å‘éƒ½ä¼šé‡‡é›†
       * data-wait: é‡‡é›†é—´éš”äº‹ä»¶ï¼Œæ¯«ç§’ï¼Œäº‹ä»¶æ¯éš”å¤šå°‘æ¯«ç§’æ‰èƒ½è§¦å‘
       * data-desc: é‡‡é›†æè¿°
       * data-uuid: é‡‡é›†å…ƒç´ çš„å”¯ä¸€æ ‡è¯†ï¼Œç”¨äºæ§åˆ¶å¤šä¸ªåŒå…ƒç´ é‡‡é›†è¡Œä¸ºï¼Œè®°å½•æ¯ä¸ªæ¡ç›®æ˜¯å¦é‡‡é›†äº†ï¼Œä¸èƒ½å­˜åœ¨uuidç›¸åŒ
       * data-exposure: å…ƒç´ æ˜¯å¦æ›å…‰é‡‡é›†
       * data-cancollected: æ˜¯å¦é‡‡é›†ï¼Œé»˜è®¤å¯ä»¥é‡‡é›†
       *
       * æ³¨æ„äº‹é¡¹ï¼š
       * 1ã€å¦‚æœä¸€ä¸ªå…ƒç´ å³è¦æ›å…‰åˆè¦ç‚¹å‡»é‡‡é›† æˆ–è€… æ—¢è¦æ›å…‰åˆè¦æ‚¬åœï¼Œæ›å…‰é…ç½®éœ€è¦åœ¨æ‚¬åœæˆ–è€…ç‚¹å‡»é…ç½®ä¸Šå±‚ï¼Œä¸ç„¶event.targetå–å€¼ä¼šæœ‰é—®é¢˜ï¼›
       * 2ã€å¦‚æœä¸€ä¸ªå…ƒç´ æ—¢è¦ç‚¹å‡»åˆè¦æ‚¬åœï¼Œå¦‚æœåŒæ—¶é…ç½®ä¼šå¯¼è‡´ä¸€ä¸ªå…¶ä¸­ä¸€ä¸ªäº‹ä»¶é‡‡é›†ä¸åˆ°ï¼Œå› ä¸ºevent.targetåªä¼šå–å±‚çº§é«˜çš„å…ƒç´ ï¼›
       * 3ã€å¦‚æœé‡‡é›†å…ƒç´ ç”±ç»„ä»¶å°è£…åœ¨å†…ï¼Œé…ç½®æ— æ³•ç©¿é€ç»„ä»¶è®¾ç½®åˆ°ç›®æ ‡å…ƒç´ ä¸Šï¼Œä¸ŠæŠ¥ä¸ä¼šè§¦å‘ã€‚ä¸€æ˜¯ä½¿ç”¨window.cassSensorsTrackæ‰‹åŠ¨ä¸ŠæŠ¥ï¼›äºŒæ˜¯åœ¨å¤–å±‚å…ƒç´ æ·»åŠ onMousedownCaptureäº‹ä»¶ç»™é‡Œé¢é‡‡é›†å…ƒç´ æ·»åŠ é…ç½®å±æ€§ï¼›
       */
      ;(function () {
        // éœ€è¦ç»‘å®šçš„äº‹ä»¶ç±»å‹
        var eventTypes = ["click", "mouseover", "scroll"];

        // ç¼“å­˜è¿›å…¥é¡µé¢åï¼Œæ‰€æœ‰åŸ‹ç‚¹äº‹ä»¶çš„è§¦å‘æ•°æ®ï¼Œæ¯”å¦‚æ˜¯å¦å·²ç»è§¦å‘è¿‡ã€‚å°†å˜é‡æŠ›å‡ºï¼Œä»¥ä¾¿å¤–é¢æ§åˆ¶
        window.cassSensorsMemo = {};

        // æ˜¯å¦åœ¨å¯è§†åŒºåŸŸå†…ï¼ˆå±å¹•ä¸­å¤® ä¸Šä¸‹90%èŒƒå›´ï¼‰
        var isInViewPort = function (ele) {
          var viewWidth = document.documentElement.clientWidth;
          var viewHeight = document.documentElement.clientHeight;
          var elePos = ele.getBoundingClientRect();
          return (
            elePos.top >= viewHeight * 0.05 &&
            elePos.left >= 0 &&
            elePos.right <= viewWidth &&
            elePos.bottom <= viewHeight * 0.95
          );
        };

        /**
         * @descption ä¸ŠæŠ¥å‡½æ•°ï¼ŒæŒ‚è½½åˆ°å…¨å±€å¯¹è±¡ä¸Šï¼Œå…¼å®¹æ‰‹åŠ¨éé…ç½®ä¸ŠæŠ¥åœºæ™¯
         * @param {object} options eventName, subEvent, desc, eventType, eventData, canFragment
         */
        window.cassSensorsTrack = (options) => {
          cassSensors.track(options.eventName, options.eventData);
        };

        /** æ›å…‰æ‹¦æˆª */
        var handleExposureIntercept = function () {
          // è·å–æ‰€æœ‰é‡‡é›†æ›å…‰çš„å…ƒç´ 
          var $exposureEles = document.querySelectorAll("[data-exposure]");
          try {
            for (var index = 0; index < $exposureEles.length; index++) {
              var $exposureEle = $exposureEles[index];
              var exposureEventName = $exposureEle.getAttribute("data-eventname");
              var exposureEventData = $exposureEle.getAttribute("data-eventdata");
              var exposureOnce = $exposureEle.getAttribute("data-once") || "false";
              var exposureWait = Number($exposureEle.getAttribute("data-wait") || "0");
              var exposureDesc = $exposureEle.getAttribute("data-desc") || "";
              var exposureUUID = $exposureEle.getAttribute("data-uuid") || exposureEventName || "";
              var exposureCollected = $exposureEle.getAttribute("data-cancollected") || "true"; // æ˜¯å¦å¯ä»¥é‡‡é›†ï¼Œé»˜è®¤å¯ä»¥é‡‡é›†
              // å¦‚æœé‡‡é›†å…ƒç´ æ²¡æœ‰ç»‘å®šäº‹ä»¶åï¼Œç›´æ¥é€€å‡º
              if (!exposureEventName) throw new Error("æ›å…‰å…ƒç´ æ²¡æœ‰ç»‘å®šäº‹ä»¶å");

              if (exposureCollected === "false") return;

              // åˆå§‹åŒ–ç¼“å­˜
              if (
                !Object.prototype.hasOwnProperty.call(
                  cassSensorsMemo,
                  exposureUUID
                )
              ) {
                cassSensorsMemo[exposureUUID] = {};
              }

              // åˆ¤æ–­æ˜¯å¦åœ¨å¯è§†åŒºåŸŸå†…
              if (isInViewPort($exposureEle)) {
                if (
                  exposureOnce === "true" &&
                  cassSensorsMemo[exposureUUID].prevExposureTime
                ) {
                  // å·²ç»é‡‡é›†è¿‡äº†ï¼Œä¸ç”¨å†æ¬¡é‡‡é›†
                  continue;
                }

                /** å¦‚æœå·²å­˜åœ¨å®šæ—¶å™¨äº†ï¼Œè¯´æ˜æ­£åœ¨æ›å…‰é‡‡é›† */
                if (cassSensorsMemo[exposureUUID].exposureTimer) {
                  continue;
                }

                if (exposureWait) {
                  (function (time, uuid, eventName, desc, data) {
                    cassSensorsMemo[uuid].exposureTimer = setTimeout(
                      function () {
                        cassSensorsMemo[uuid].prevExposureTime = Date.now();
                        cassSensorsTrack({
                          eventName,
                          desc,
                          eventType: "scroll",
                          eventData: data,
                        });
                        clearTimeout(cassSensorsMemo[uuid].exposureTimer);
                        cassSensorsMemo[uuid].exposureTimer = null; // clearTimeoutå¯ä»¥æ¸…æ¥šçš„æ‰å®šæ—¶å™¨ï¼Œä½†ä¸ä¼šæ›´æ”¹cassSensorsMemo[uuid].exposureTimerçš„å€¼ï¼Œéœ€è¦æ‰‹åŠ¨ç½®ç©º
                      },
                      time
                    );
                  })(
                    exposureWait,
                    exposureUUID,
                    exposureEventName,
                    exposureDesc,
                    exposureEventData
                  );
                } else {
                  // æ— éœ€ç­‰å¾…
                  cassSensorsMemo[exposureUUID].prevExposureTime = Date.now();
                  cassSensorsTrack({
                    eventName: exposureEventName,
                    desc: exposureDesc,
                    eventType: "scroll",
                    eventData: exposureEventData,
                  });
                  clearTimeout(cassSensorsMemo[exposureUUID].exposureTimer);
                  cassSensorsMemo[exposureUUID].exposureTimer = null;
                }
              } else {
                /** ä¸åœ¨è§†å›¾åŒºåŸŸçš„æ¸…é™¤å®šæ—¶å™¨ */
                clearTimeout(cassSensorsMemo[exposureUUID].exposureTimer);
                cassSensorsMemo[exposureUUID].exposureTimer = null;
              }
            }
          } catch (error) {
            return;
          }
        };

        // æ‹¦æˆªæ•è·äº‹ä»¶
        var handleEventIntercept = function (event) {
          /** ç‚¹å‡»ã€æ‚¬æµ® */
          if (["click", "mouseover"].includes(event.type)) {
            try {
              // documentå…ƒç´ æ²¡æœ‰getAttributeæ–¹æ³•
              var eventName = event.target.getAttribute("data-eventname") || ""; // äº‹ä»¶åç§°
              var eventData = event.target.getAttribute("data-eventdata") || ""; // é‡‡é›†æ•°æ®
              var eventType = event.target.getAttribute("data-eventtype") || ""; // äº‹ä»¶ç±»å‹
              var once = event.target.getAttribute("data-once") || "false"; // è¿›å…¥é¡µé¢åæ˜¯å¦åªè§¦å‘ä¸€æ¬¡
              var wait = Number(event.target.getAttribute("data-wait") || "0"); // äº‹ä»¶é—´éš”ï¼Œæ¯”å¦‚é¼ æ ‡æ‚¬åœæ—¶é•¿ï¼Œæ¯«ç§’
              var desc = event.target.getAttribute("data-desc") || ""; // é‡‡é›†æè¿°
              var uuid = event.target.getAttribute("data-uuid") || eventName || ""; // é‡‡é›†æè¿°
              var canCollected = event.target.getAttribute("data-cancollected") || "true"; // æ˜¯å¦å¯ä»¥é‡‡é›†ï¼Œé»˜è®¤å¯ä»¥é‡‡é›†

              if (canCollected === "false") return;
            } catch (error) {
              return;
            }

            // é¼ æ ‡ç‚¹å‡»
            if (event.type === "click") {
              /** ç‚¹å‡»çš„å½“å‰å…ƒç´ éé‡‡é›†å…ƒç´  */
              if (eventType !== event.type || !eventName) {
                return;
              }

              // åˆå§‹åŒ–ç¼“å­˜
              if (
                !Object.prototype.hasOwnProperty.call(cassSensorsMemo, uuid)
              ) {
                cassSensorsMemo[uuid] = {};
              }

              if (once === "true" && cassSensorsMemo[uuid].prevClickTime) {
                return; // å·²ç»é‡‡é›†è¿‡äº†
              }
              if (wait) {
                if (cassSensorsMemo[uuid].prevClickTime) {
                  // ä¸Šæ¬¡è®¿é—®æ—¶é—´ç‚¹ä¸å½“å‰æ—¶é—´ç‚¹æ¯”è¾ƒ
                  if (
                    Date.now() - cassSensorsMemo[uuid].prevClickTime >=
                    wait
                  ) {
                    cassSensorsMemo[uuid].prevClickTime = Date.now();
                    cassSensorsTrack({
                      eventName,
                      desc,
                      eventType,
                      eventData,
                    });
                  }
                } else {
                  // æ²¡æœ‰è§¦å‘è¿‡
                  cassSensorsMemo[uuid].prevClickTime = Date.now();
                  cassSensorsTrack({
                    eventName,
                    desc,
                    eventType,
                    eventData,
                  });
                }
              } else {
                // æ— éœ€ç­‰å¾…
                cassSensorsMemo[uuid].prevClickTime = Date.now();
                cassSensorsTrack({
                  eventName,
                  desc,
                  eventType,
                  eventData,
                });
              }
            }

            // æ‚¬æµ®
            if (event.type === "mouseover") {
              /** æ‚¬åœçš„å½“å‰å…ƒç´ éé‡‡é›†å…ƒç´ ï¼Œå°†å…¶ä»–é‡‡é›†å…ƒç´ çš„å®šæ—¶å™¨æ¸…é™¤ */
              if (eventType !== event.type || !eventName) {
                Object.keys(cassSensorsMemo).forEach(function (uid) {
                  var memoItem = cassSensorsMemo[uid];
                  if (
                    Object.prototype.hasOwnProperty.call(memoItem, "hoverTimer")
                  ) {
                    clearTimeout(memoItem.hoverTimer);
                    memoItem.hoverTimer = null;
                  }
                });
                return;
              }

              // åˆå§‹åŒ–ç¼“å­˜
              if (
                !Object.prototype.hasOwnProperty.call(cassSensorsMemo, uuid)
              ) {
                cassSensorsMemo[uuid] = {};
              }

              if (once === "true" && cassSensorsMemo[uuid].prevHoverTime) {
                return; // å·²ç»é‡‡é›†è¿‡äº†
              }

              // å¦‚æœå½“å‰å…ƒç´ å·²å­˜åœ¨å®šæ—¶å™¨ï¼Œç›´æ¥return
              if (cassSensorsMemo[uuid].hoverTimer) {
                return;
              }

              if (wait) {
                // æ‚¬åœé‡‡é›†
                cassSensorsMemo[uuid].hoverTimer = setTimeout(() => {
                  cassSensorsMemo[uuid].prevHoverTime = Date.now();
                  cassSensorsTrack({
                    eventName,
                    desc,
                    eventType,
                    eventData,
                  });
                  // é‡‡é›†åæ¸…é™¤å®šæ—¶å™¨
                  clearTimeout(cassSensorsMemo[uuid].hoverTimer);
                  cassSensorsMemo[uuid].hoverTimer = null;
                }, wait);
              } else {
                // ç«‹å³è§¦å‘
                cassSensorsMemo[uuid].prevHoverTime = Date.now();
                cassSensorsTrack({
                  eventName,
                  desc,
                  eventType,
                  eventData,
                });
              }
            }
          }

          /** æ›å…‰ */
          if (event.type === "scroll") {
            handleExposureIntercept();
          }
        };

        /** é˜²æŠ–å‡½æ•° */
        var debounce = function (fn, wait) {
          var timer = null;
          return function (args) {
            var that = this;
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }
            timer = setTimeout(function () {
              fn.call(that, args);
              clearTimeout(timer);
              timer = null;
            }, wait);
          };
        };

        /** åˆå§‹è¿›å…¥é¡µé¢ï¼Œæ²¡æœ‰è§¦å‘æ»šåŠ¨ï¼Œå¯è§†åŒºåŸŸå†…çš„ç›®æ ‡å…ƒç´ éœ€è¦é‡‡é›†æ›å…‰ï¼›æˆ–è€…å¼¹å‡ºæµ®çª—å†…çš„ç›®æ ‡å…ƒç´ ä¹Ÿè¦é‡‡é›†æ›å…‰ */
        var exposureListener = function () {
          // é€‰æ‹©éœ€è¦è§‚å¯Ÿå˜åŠ¨çš„èŠ‚ç‚¹
          var targetNode = document.getElementById("root");

          // è§‚å¯Ÿå™¨çš„é…ç½®ï¼ˆéœ€è¦è§‚å¯Ÿä»€ä¹ˆå˜åŠ¨ï¼‰
          var config = { attributes: false, childList: true, subtree: true };

          var debounceExposureIntercept = debounce(
            handleExposureIntercept,
            200
          );

          // å½“è§‚å¯Ÿåˆ°å˜åŠ¨æ—¶æ‰§è¡Œçš„å›è°ƒå‡½æ•°
          var callback = function (mutationsList, observer) {
            if (
              mutationsList.some(function (mutation) {
                // A child node has been added or removed.
                return (
                  mutation.type === "childList" && !!mutation.addedNodes.length
                );
              })
            ) {
              /** åªæœ‰å…ƒç´ èŠ‚ç‚¹å¢åŠ çš„æƒ…å†µæ‰è§¦å‘æ›å…‰ */
              debounceExposureIntercept();
            }
          };
          // åˆ›å»ºä¸€ä¸ªè§‚å¯Ÿå™¨å®ä¾‹å¹¶ä¼ å…¥å›è°ƒå‡½æ•°
          var observer = null;
          var isIE =
            navigator.userAgent.indexOf("compatible") > -1 &&
            navigator.userAgent.indexOf("MSIE") > -1;
          if (isIE) {
            // the return value of "test" must be used
            var valid = new RegExp("MSIE (\\d+\\.\\d+);").test(
              navigator.userAgent
            );
            if (parseFloat(RegExp.$1) < 11) {
              // IE 11 ä»¥ä¸‹ä¸æ”¯æŒMutationObserverï¼Œä½¿ç”¨polyfillï¼Œè™½ç„¶JsMutationObserverçš„å®ç°ä½¿ç”¨äº†WeakMapï¼Œä½†è¯¥æ–‡ä»¶ä¹‹å‰å¼•å…¥äº†corejsï¼Œæœ‰åŸç”Ÿå®ç°çš„WeakMap
              // https://github.com/talee/mutationobserver-breaks-characterdata
              observer = new JsMutationObserver(callback);
            } else {
              observer = new MutationObserver(callback);
            }
          } else {
            observer = new MutationObserver(callback);
          }

          // ä»¥ä¸Šè¿°é…ç½®å¼€å§‹è§‚å¯Ÿç›®æ ‡èŠ‚ç‚¹
          observer.observe(targetNode, config);

          // ä¹‹åï¼Œå¯åœæ­¢è§‚å¯Ÿ
          window.onunload = function () {
            observer.disconnect();
          };
        };

        /** ç»‘å®šäº‹ä»¶ */
        var bindEvents = function () {
          var debounceIntercept = debounce(handleEventIntercept, 100);
          eventTypes.forEach(function (eventType) {
            var isDebounce = ["scroll"].includes(eventType);
            document.addEventListener(
              eventType,
              isDebounce ? debounceIntercept : handleEventIntercept,
              true
            );
          });
          window.onunload = function () {
            eventTypes.forEach(function (eventType) {
              document.removeEventListener(
                eventType,
                isDebounce ? debounceIntercept : handleEventIntercept,
                true
              );
            });
          };
        };

        window.addEventListener("load", function () {
          /** ç»‘å®šæ‹¦æˆªäº‹ä»¶ */
          bindEvents();
          /** åˆå§‹æ›å…‰é‡‡é›† */
          exposureListener();
        });
      })();
    </script>
  </body>
</html>
```

æœ‰å‡ ä¸ªç‰¹æ®Šåœºæ™¯éœ€è¦æ³¨æ„ï¼š

*   æ›å…‰é‡‡é›†ï¼Œåˆå§‹é¡µé¢å¯è§†åŒºåŸŸçš„ç›®æ ‡å…ƒç´ ï¼Œå’Œç”¨æˆ·äº¤äº’åå‘ˆç°å‡ºçš„ç›®æ ‡å…ƒç´ åº”å½“å¦‚ä½•é‡‡é›†ï¼Ÿç”±äºæ­¤æ—¶æ²¡æœ‰è§¦å‘æ»šåŠ¨äº‹ä»¶ï¼Œ`scroll`äº‹ä»¶å›è°ƒæ•è·ä¸åˆ°ï¼Œå¯ä»¥åˆ©ç”¨`MutationObserver API`ç›‘å¬é¡µé¢æ˜¯å¦æœ‰æ–°å¢`DOM`ï¼Œå¦‚æœæœ‰åˆ™æ‰§è¡Œæ›å…‰é‡‡é›†é€»è¾‘ã€‚`IE 11`ä»¥ä¸‹ä¸æ”¯æŒ`MutationObserver API`ï¼Œ`core-js3`å¹¶æ²¡æœ‰å®ç°ï¼Œå¯å•ç‹¬å¼•å…¥`polyfill`æ¥å®ç°ï¼›
*   æ‚¬åœé‡‡é›†æ–¹æ¡ˆï¼Œä¸€ç§æ˜¯ä½¿ç”¨`mouseenter`ä¸`mouseoutã€mouseleave`ç»„åˆäº‹ä»¶ç›‘å¬æ‚¬åœï¼›å¦ä¸€ç§æ˜¯ä½¿ç”¨`mouseover`ç›‘å¬æ‚¬æµ®ï¼Œå¦‚æœæ‚¬æµ®çš„æ˜¯ç›®æ ‡å…ƒç´ åˆ™æ‰§è¡Œé‡‡é›†é€»è¾‘ã€‚å¦‚æœæ‚¬æµ®çš„ä¸æ˜¯ç›®æ ‡å…ƒç´ åˆ™æ¸…é™¤æ‰€æœ‰æ‚¬åœå®šæ—¶å™¨ï¼›
*   å¦‚æœä¸€ä¸ªå…ƒç´ æ—¢è¦ç‚¹å‡»é‡‡é›†åˆè¦æ‚¬åœé‡‡é›†ï¼ŒåµŒå¥—å±æ€§é…ç½®ä¼šå¯¼è‡´å…¶ä¸­ä¸€ä¸ªäº‹ä»¶é‡‡é›†ä¸åˆ°ï¼Œå› ä¸º`event.target`å¯¹åº”å±‚çº§é«˜çš„å…ƒç´ ï¼Œåªæ‹¿å¾—åˆ°ä¸€ä¸ªå±æ€§é…ç½®é¡¹ã€‚è§£å†³æ–¹æ³•ä¸€æ˜¯æ”¹é€ ä¸Šè¿°é…ç½®è§„åˆ™ï¼Œå¯é…ç½®å¤šäº‹ä»¶å±æ€§ï¼›äºŒæ˜¯å…¶ä¸­ä¸€ç§äº‹ä»¶æ”¹æˆæ‰‹åŠ¨é‡‡é›†ï¼›
    
    ```
    <div 
      data-eventname="\['CLICK\_EVENT, MOUSEOVER\_EVENT'\]",
      data-eventtype="\['click', 'mouseover'\]",
      data-once="\['false', 'true'\]",
      data-wait="\[1000, 2000\]",
      data-eventdata="\[{ id: 'click' }, { id: ''mouseover' }\]"  
    >
      ç›®æ ‡å…ƒç´ 
    </div>
    
    <div onclick="handleClickTrack()">
      <div
        data-eventname="MOUSEOVER_EVENT",
        data-eventtype="mouseover"
        data-once="true" 
        data-wait="2000"
        data-eventdata="{ id: 'mouseover' }"
      >
        ç›®æ ‡å…ƒç´ 
      </div>
    </div>
    <script> var handleClickTrack = function() {
        cassSensors.track(eventName, eventData);
      } </script>
    ```
    
*   å¦‚æœç›®æ ‡å…ƒç´ å°è£…åœ¨ç»„ä»¶å†…ï¼Œå±æ€§é…ç½®é¡¹æ— æ³•ç©¿é€ç»„ä»¶ç›´æ¥è®¾ç½®åˆ°ç›®æ ‡å…ƒç´ ä¸Šï¼Œä¸ŠæŠ¥ä¸ä¼šè§¦å‘ã€‚è§£å†³æ–¹æ³•ä¸€æ˜¯ä½¿ç”¨`window.cassSensorsTrack`æ‰‹åŠ¨ä¸ŠæŠ¥ï¼›äºŒæ˜¯åœ¨å¤–å±‚å…ƒç´ æ·»åŠ `onMousedownCapture`äº‹ä»¶æ•è·æ‹¦æˆªï¼Œç»™ç»„ä»¶å†…ç›®æ ‡å…ƒç´ æ·»åŠ å±æ€§é…ç½®ï¼›
    
    ```
    const Button = () =\> <span id="target"></span>
    
    const handleClickTrack = () =\> {
      cassSensors.track(eventName, eventData);
    }
    <div onClick={handleClickTrack}><Button /></div>
    
    const handleMousedownIntercept = () =\> {
      const $target = document.getElementById('target');
      if ($target) {
        $target.setAttribute('data-eventname', 'CLICK_EVENT');
        $target.setAttribute('data-eventtype', 'click');
        $target.setAttribute('data-eventdata', '{ id: "click" }');
        $target.setAttribute('data-once', 'false');
        $target.setAttribute('data-wait', '1000');
      }
    }
    <div onMousedownCapture={handleMousedownIntercept}><Button /></div>
    ```
    
    > æ³¨ï¼šå°è£…åŸ‹ç‚¹æ’ä»¶ä¸é‡‡ç”¨å†’æ³¡æœºåˆ¶ï¼Œè€Œé‡‡ç”¨æ•è·æœºåˆ¶çš„åŸå› æ˜¯æœ‰äº›ä¸šåŠ¡åœºæ™¯ä¸‹ï¼Œäº‹æƒ…éœ€è¦é˜»æ­¢å†’æ³¡ï¼Œå¯èƒ½å½±å“åˆ°æ•°æ®é‡‡é›†
    

### æ€»ç»“

ä»¥ä¸Šä¸‰ç§æ–¹æ¡ˆå‡èƒ½æŠ½ç¦»å°è£…é‡‡é›†é€»è¾‘ï¼Œä¼˜é›…å®ç°æ•°æ®ä¸ŠæŠ¥ï¼Œç›¸å¯¹è€Œè¨€ï¼Œç¬¬ä¸€ç§`Hooks`å®ç°æ›´ä¸ºç®€å•ï¼Œä¾¿äºç†è§£å’Œç»´æŠ¤ã€‚ç¬¬ä¸‰ç§æ’æ‹”å¼æ’ä»¶å°è£…å¥½å¤„åœ¨äºå¯åœ¨ä¸åŒæŠ€æœ¯æ ˆä¸­ä½¿ç”¨ï¼Œä½†é…ç½®é¡¹è¾ƒä¸ºå¤æ‚ã€‚